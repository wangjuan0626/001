//贪心算法:在对问题求解时，总是做出在当前看来是最好的选择。
//基本思路:1>建立数学模型来描述问题;2>把求解的问题分成若干个问题;3>对每一子问题求解，得到子问题的局部最优解;4>把子问题的解局部最优解合成原来问题的一个解。
//贪心算法的实现框架:
/*从问题的某一初始解出发；
  while(能朝给定总目标前进一步）
  {
  	利用可行的决策，求出可行解的一个解元素；
  }
  由所有解元素组合成一个问题的可行解.*/
   

#include <stdio.h>
void schedule(int m,int n,int *t)
{
	//数据初始化
	int i,j,k,max=0;
	int d[100],s[100][100],count[100];
	for(i=0;i<m;i++)
	{
		d[i]=0;
		for(j=0;j<n;j++)
			s[i][j]=-1;//-1代表不执行任何任务 
	} 
	//分配前m个任务
	//首先让每个机器分别接受一个任务
	for(i=0;i<m;i++)
	{
		s[i][0]=i;
		d[i]=d[i]+t[i];
		count[i]=1;
	} 
	//判断哪个机器任务耗时最少，让其接受任务
	//尽可能地平行、平均分配任务
	for(i=m;i<n;i++)
	{
		int min=d[0];
		k=0;
		for(j=1;j<m;j++)//确定空闲机器，实质上是求当前任务总时间最少的机器 
			if(min>d[j])
			{
				min=d[j];
				k=j;//机器k空闲 
			}
	s[k][count[k]]=i;//在机器k的执行队列添加第i号任务
	count[k]=count[k]+1;//机器k的任务加一；
	d[k]=d[k]+t[i];//机器k的任务执行时间+t[i]，也就是+第i号任务的耗时
	}
	
	for(i=0;i<m;i++)//确定完成所有任务时间，实质是求分配完所有任务之后耗时最多的机器 
	{
		if(max<d[i])
			max=d[i];
	} 
	
	printf("完成所有任务需要的时间：%d\n",max);
	printf("各个机器执行的时间一览：\n");
	for(i=0;i<m;i++)
	{
		printf("%d:",i);
		for(j=0;j<n;j++)
		{
			if(s[i][j]==-1)
				break;
			printf("%d\t",t[s[i][j]]);
		}
		printf("\n");
	}
}
int main()
{
	int time[7]={16,14,6,5,4,3,2};
	schedule(3,7,time);
}
